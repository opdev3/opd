<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>contract API documentation</title>
<meta name="description" content="This project is intended to provide an easy and efficient way to lend and/or borrow tokens and XTZ on Tezos blockchain â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>contract</code></h1>
</header>
<section id="section-intro">
<p>This project is intended to provide an easy and efficient way to lend and/or borrow tokens and XTZ on Tezos blockchain.</p>
<p>This version allows users to use only XTZ as collateral.
The current implementation supports FA1.2.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This project is intended to provide an easy and efficient way to lend and/or borrow tokens and XTZ on Tezos blockchain.

This version allows users to use only XTZ as collateral.
The current implementation supports FA1.2.
&#34;&#34;&#34;

import smartpy as sp


class Error:
    &#34;&#34;&#34;The enum used for the contract related errors.&#34;&#34;&#34;

    ACCESS_DENIED = &#34;OD_ACCESS_DENIED&#34;
    &#34;&#34;&#34;The contract function is not accessible for the sender.&#34;&#34;&#34;

    ILLEGAL_ARGUMENT = &#34;OD_ILLEGAL_ARGUMENT&#34;
    &#34;&#34;&#34;The corresponding argument value is invalid.&#34;&#34;&#34;

    ILLEGAL_TX_AMOUNT = &#34;OD_ILLEGAL_TX_AMOUNT&#34;
    &#34;&#34;&#34;The corresponding transaction has incorrect tezos amount.&#34;&#34;&#34;

    PAUSED = &#34;OD_PAUSED&#34;
    &#34;&#34;&#34;The contract is paused.&#34;&#34;&#34;



class Opus(sp.Contract):
    &#34;&#34;&#34;The contract is a storage for p2p credit deals and provides service functionality to make such deals.&#34;&#34;&#34;

    def __init__(self, creator):
        self.creator = creator

        self.init(
            # indicates that making of credit deals is disabled
            # (if the value is True, creating loan requests and making deals are not possible)
            pause = False,

            # baker address or None
            baker = sp.none,

            # list of admin addresses
            admins = sp.set([creator]),

            # supported tokens (list of pairs: token name and token address)
            tokens = sp.big_map(tkey = sp.TString, tvalue = sp.TAddress),

            # time bounds for credit deals
            time = sp.record(min = sp.nat(7 * 86400), max = sp.nat(180 * 86400)),

            # minimum deposit value
            min_deposit = sp.tez(1),

            # service fee (APY) in basis points
            fee = sp.nat(100),

            # last loan request ID
            nloan = sp.nat(0),

            # last credit deal ID
            ndeal = sp.nat(0),

            # map of loan requests (key is loan request ID)
            loans = sp.big_map(),

            # map of credit deals (key is credit deal ID)
            deals = sp.big_map(),

            # amount of blocked collateral
            deposits = sp.mutez(0)
        )


    @sp.entry_point
    def default(self):
        &#34;&#34;&#34;Support tezos transfer to the contract address.&#34;&#34;&#34;
        pass


    @sp.entry_point
    def withdraw(self, params):
        &#34;&#34;&#34;(Admins only) Transfer tezos (except blocked collateral) from the contract address.
        
        Args:
            address (address): destination address
            amount (mutez): tezos amount
        Raises:
            `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.set_type(params.amount, sp.TMutez)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(params.amount &gt; sp.mutez(0), message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.verify((sp.balance - self.data.deposits) &gt;= params.amount, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.send(params.address, params.amount)


    @sp.entry_point
    def add_admin(self, params):
        &#34;&#34;&#34;(Admins only) Add an admin address to the list of admin addresses.
        
        Args:
            address (address): new admin address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(~self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        self.data.admins.add(params.address)


    @sp.entry_point
    def remove_admin(self, params):
        &#34;&#34;&#34;(Admins only) Remove an admin address from the list of admin addresses.

        Args:
            address (address): admin address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.creator != params.address, message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        sp.verify(self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        self.data.admins.remove(params.address)


    @sp.entry_point
    def pause(self, params):
        &#34;&#34;&#34;(Admins only) Disable/enable making of new loan requests and new deals.

        Args:
            pause (bool): _True_ or _False_
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.pause, sp.TBool)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.pause != params.pause, message = Error.ILLEGAL_ARGUMENT + &#34;:pause&#34;)
        self.data.pause = params.pause


    @sp.entry_point
    def delegate(self, params):
        &#34;&#34;&#34;(Admins only) Set a baker for the contract.

        Args:
            baker (option): baker address or _None_
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.baker, sp.TOption(sp.TKeyHash))
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.baker != params.baker, message = Error.ILLEGAL_ARGUMENT + &#34;:baker&#34;)
        self.data.baker = params.baker
        sp.set_delegate(params.baker)


    @sp.entry_point
    def add_token(self, params):
        &#34;&#34;&#34;(Admins only) Add supported token.

        Args:
            name (string): token name
            address (address): token address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`
        &#34;&#34;&#34;
        sp.set_type(params.name, sp.TString)
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        self.data.tokens[params.name] = params.address


    @sp.entry_point
    def remove_token(self, params):
        &#34;&#34;&#34;(Admins only) Remove supported token.

        Args:
            name (string): token name
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.name, sp.TString)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.tokens.contains(params.name), message = Error.ILLEGAL_ARGUMENT + &#34;:name&#34;)
        del self.data.tokens[params.name]


    @sp.entry_point
    def set_fee(self, params):
        &#34;&#34;&#34;(Admins only) Set a service fee.

        Args:
            fee (nat): fee value (APY) in basis points
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.fee, sp.TNat)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.fee != params.fee, message = Error.ILLEGAL_ARGUMENT + &#34;:fee&#34;)
        sp.verify(params.fee &lt; 10000, message = Error.ILLEGAL_ARGUMENT + &#34;:fee&#34;)
        self.data.fee = params.fee


    @sp.entry_point
    def set_min_deposit(self, params):
        &#34;&#34;&#34;(Admins only) Set minimum deposit value for loan requests.

        Args:
            min_deposit (mutez): minimum deposit value
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.min_deposit, sp.TMutez)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.min_deposit != params.min_deposit, message = Error.ILLEGAL_ARGUMENT + &#34;:min_deposit&#34;)
        self.data.min_deposit = params.min_deposit


    @sp.entry_point
    def set_time(self, params):
        &#34;&#34;&#34;(Admins only) Set time bounds for credit deals.

        Args:
            min (nat): minimum deal duration in seconds
            max (nat): maximum deal duration in seconds
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params, sp.TRecord(min = sp.TNat, max = sp.TNat))
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.time != params, message = Error.ILLEGAL_ARGUMENT + &#34;:min,max&#34;)
        sp.verify((params.min &gt; 0) &amp; (params.min &lt;= params.max), message = Error.ILLEGAL_ARGUMENT + &#34;:min&#34;)
        self.data.time = params


    @sp.entry_point
    def add_loan(self, params):
        &#34;&#34;&#34;Create a new loan request.
        
        The corresponding transaction amount has to include deposit and service fee.

        Args:
            token (string): token name
            token_address (address): token address
            amount (nat): requested amount of tokens
            reward (nat): amount of tokens as creditor&#39;s reward 
            deposit (mutez): deposit amount, the sender has to send the same amount of tezos
            time (nat): credit deal duration in seconds
            validity (option): loan request expire date or None
        Raises:
            `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.token, sp.TString)
        sp.set_type(params.token_address, sp.TAddress)
        sp.set_type(params.amount, sp.TNat)
        sp.set_type(params.reward, sp.TNat)
        sp.set_type(params.deposit, sp.TMutez)
        sp.set_type(params.time, sp.TNat)
        sp.set_type(params.validity, sp.TOption(sp.TTimestamp))
        sp.verify(~self.data.pause, message = Error.PAUSED)
        sp.verify(self.data.tokens.contains(params.token), message = Error.ILLEGAL_ARGUMENT + &#34;:token&#34;)
        sp.verify(self.data.tokens[params.token] == params.token_address, message = Error.ILLEGAL_ARGUMENT + &#34;:token_address&#34;)
        sp.verify(params.amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.verify(params.deposit &gt;= self.data.min_deposit, message = Error.ILLEGAL_ARGUMENT + &#34;:deposit&#34;)
        sp.verify((params.time &gt;= self.data.time.min) &amp; (params.time &lt;= self.data.time.max), message = Error.ILLEGAL_ARGUMENT + &#34;:time&#34;)
        sp.verify((params.validity == sp.none) | (params.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:validity&#34;)
        # Service fee calculation
        f = sp.local(&#34;f&#34;, sp.utils.nat_to_mutez(sp.utils.mutez_to_nat(params.deposit) * params.time * self.data.fee // (3600 * 24 * 365 * 100 * 100)))
        sp.verify(sp.amount == (params.deposit + f.value), message = Error.ILLEGAL_TX_AMOUNT)
        loan = sp.record(
            ts = sp.now,
            borrower = sp.sender,
            validity = params.validity,
            amount = params.amount,
            token = params.token,
            token_address = self.data.tokens[params.token],
            time = params.time,
            reward = params.reward,
            deposit = params.deposit,
            fee = f.value
        )
        self.data.nloan += 1
        self.data.loans[self.data.nloan] = loan
        self.data.deposits += sp.amount


    @sp.entry_point
    def cancel_loan(self, params):
        &#34;&#34;&#34;Cancel sender&#39;s loan request, deposit and fee of the loan are returned to the sender.

        Args:
            id (nat): loan request ID
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
        sp.verify((sp.sender == loan.value.borrower) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
        with sp.if_(loan.value.deposit &gt; sp.mutez(0)):
            sp.send(loan.value.borrower, loan.value.deposit + loan.value.fee)
            self.data.deposits -= (loan.value.deposit + loan.value.fee)
        del self.data.loans[params.id]


    @sp.entry_point
    def make_deal(self, params):
        &#34;&#34;&#34;Make a credit deal, the sender has to approve the corresponding token transfer early.

        Args:
            id (nat): loan request ID
        Raises:
            `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(~self.data.pause, message = Error.PAUSED)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
        sp.verify(loan.value.borrower != sp.sender, Error.ILLEGAL_ARGUMENT + &#34;:sender&#34;)
        sp.verify((loan.value.validity == sp.none) | (loan.value.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:now&#34;)
        deal = sp.record(
            ts = sp.now,
            borrower = loan.value.borrower,
            creditor = sp.sender,
            amount = loan.value.amount,
            token = loan.value.token,
            token_address = loan.value.token_address,
            exp = sp.now.add_seconds(sp.to_int(loan.value.time)),
            reward = loan.value.reward,
            deposit = loan.value.deposit,
        )
        self.transfer_tokens(f=sp.sender, t=loan.value.borrower, v=loan.value.amount, token_address=loan.value.token_address)
        self.data.ndeal += 1
        self.data.deals[self.data.ndeal] = deal
        self.data.deposits -= loan.value.fee
        del self.data.loans[params.id]


    @sp.entry_point
    def close_deal(self, params):
        &#34;&#34;&#34;Close a deal by borrower or creditor/admins.

        If a deal is closed by borrower, the tokens are sent to the creditor and the borrower gets back the deposit;
        if a deal timed out and it&#39;s closed by the creditor or admins, the creditor gets the deposit.

        Args:
            id (nat): credit deal ID
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.deals.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        deal = sp.local(&#34;deal&#34;, self.data.deals[params.id])
        sp.verify((sp.sender == deal.value.borrower) | (sp.sender == deal.value.creditor) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
        with sp.if_(sp.sender == deal.value.borrower):
            self.transfer_tokens(f=deal.value.borrower, t=deal.value.creditor, v=(deal.value.amount+deal.value.reward), token_address=deal.value.token_address)
            with sp.if_(deal.value.deposit &gt; sp.mutez(0)):
                sp.send(deal.value.borrower, deal.value.deposit)
                self.data.deposits -= deal.value.deposit
        with sp.else_():
            sp.verify(deal.value.exp &lt; sp.now, message = Error.ACCESS_DENIED)
            with sp.if_(deal.value.deposit &gt; sp.mutez(0)):
                sp.send(deal.value.creditor, deal.value.deposit)
                self.data.deposits -= deal.value.deposit
        del self.data.deals[params.id]


    def transfer_tokens(self, f, t, v, token_address):
        &#34;&#34;&#34;Help function to transfer tokens.

        Args:
            f (address): source address
            t (address): destination address
            v (nat): amount of tokens
            token_address (address): token smart-contract address
        &#34;&#34;&#34;
        param_type = sp.TRecord(from_ = sp.TAddress, to_ = sp.TAddress, value = sp.TNat).layout((&#34;from_ as from&#34;, (&#34;to_ as to&#34;, &#34;value&#34;)))
        param_values = sp.record(from_ = f, to_ = t, value = v)
        sp.transfer(param_values, sp.mutez(0), sp.contract(param_type, token_address, entry_point=&#34;transfer&#34;).open_some())



#########################################################################################################
@sp.add_test(name = &#34;Opus&#34;)
def test():
    &#34;&#34;&#34;Tests.&#34;&#34;&#34;
    creator = sp.address(&#34;tz1fE6hEiRFa9ZHJeZrccNKsGW7jdxfe9vcv&#34;)
    DAY = 86400
    admin = sp.test_account(&#34;Admin&#34;)
    userA = sp.test_account(&#34;UserA&#34;)
    userB = sp.test_account(&#34;UserB&#34;)
    userC = sp.test_account(&#34;UserC&#34;)
    scenario = sp.test_scenario()
    scenario.h1(&#34;Opus tests&#34;)
    c1 = Opus(creator)
    INITIAL_BALANCE = sp.tez(1000)
    c1.set_initial_balance(INITIAL_BALANCE)
    scenario += c1


    scenario.h1(&#34;Admins&#34;)
    scenario.h2(&#34;add_admin()&#34;)
    c1.add_admin(address=userA.address).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.add_admin(address=userA.address).run(sender = userA, valid = False)
    c1.add_admin(address=admin.address).run(sender = creator)
    c1.add_admin(address=admin.address).run(sender = creator, valid = False)
    c1.add_admin(address=userA.address).run(sender = admin)
    scenario.h2(&#34;remove_admin()&#34;)
    c1.remove_admin(address=userA.address).run(sender = admin, amount=sp.mutez(1), valid = False)
    c1.remove_admin(address=admin.address).run(sender = userB, valid = False)
    c1.remove_admin(address=creator).run(sender = admin, valid = False)
    c1.remove_admin(address=userA.address).run(sender = admin)
    c1.remove_admin(address=userA.address).run(sender = admin, valid = False)


    scenario.h1(&#34;Delegate&#34;)
    scenario.h2(&#34;delegate()&#34;)
    keyHash = sp.key_hash(&#34;tz1fwnfJNgiDACshK9avfRfFbMaXrs3ghoJa&#34;)
    voting_powers = {keyHash : 0}
    c1.delegate(baker=sp.some(keyHash)).run(sender = admin, voting_powers = voting_powers, amount=sp.mutez(1), valid = False)
    c1.delegate(baker=sp.some(keyHash)).run(sender = userB, voting_powers = voting_powers, valid = False)
    c1.delegate(baker=sp.some(keyHash)).run(sender = admin, voting_powers = voting_powers)
    c1.delegate(baker=sp.some(keyHash)).run(sender = admin, voting_powers = voting_powers, valid = False)
    scenario.verify_equal(c1.baker, sp.some(keyHash))
    c1.delegate(baker=sp.none).run(sender = admin)


    scenario.h1(&#34;Tokens&#34;)
    tokenBTC = sp.record(name=&#34;sBTC&#34;, address=sp.address(&#34;tz1oBTCoMEtsXm3QxA7FmMU2Qh7xzsuGXVbc&#34;))
    tokenETH = sp.record(name=&#34;sETH&#34;, address=sp.address(&#34;tz1oETHo1otsXm3QxA7FmMU2Qh7xzsuGXVbc&#34;))
    tokenXPR = sp.record(name=&#34;sXRP&#34;, address=sp.address(&#34;tz1oXRPoMEtsXm3QxA7FmMU2Qh7xzsuGXVbc&#34;))
    scenario.h2(&#34;add_token()&#34;)
    c1.add_token(tokenBTC).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.add_token(tokenBTC).run(sender = creator)
    c1.add_token(tokenETH).run(sender = userA, valid = False)
    c1.add_token(name=tokenETH.name, address=sp.address(&#34;tz1oETHo2otsXm3QxA7FmMU2Qh7xzsuGXVbc&#34;)).run(sender = creator)
    c1.add_token(tokenETH).run(sender = admin)
    c1.add_token(tokenXPR).run(sender = admin)
    scenario.h2(&#34;remove_token()&#34;)
    c1.remove_token(name=&#34;sBTC&#34;).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.remove_token(name=&#34;sBTC&#34;).run(sender = userA, valid = False)
    c1.remove_token(name=&#34;yyyy&#34;).run(sender = creator, valid = False)
    c1.remove_token(name=&#34;sXRP&#34;).run(sender = creator)


    scenario.h1(&#34;Fee&#34;)
    scenario.h2(&#34;set_fee()&#34;)
    c1.set_fee(fee=0).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.set_fee(fee=0).run(sender = userA, valid = False)
    c1.set_fee(fee=100).run(sender = creator, valid = False)
    c1.set_fee(fee=10000).run(sender = creator, valid = False)
    c1.set_fee(fee=0).run(sender = creator)
    c1.set_fee(fee=100).run(sender = admin)


    scenario.h1(&#34;Min Deposit&#34;)
    scenario.h2(&#34;set_min_deposit()&#34;)
    c1.set_min_deposit(min_deposit=sp.mutez(100)).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.set_min_deposit(min_deposit=sp.mutez(0)).run(sender = userA, valid = False)
    c1.set_min_deposit(min_deposit=sp.mutez(1_000_000)).run(sender = creator, valid = False)
    c1.set_min_deposit(min_deposit=sp.mutez(0)).run(sender = admin)
    c1.set_min_deposit(min_deposit=sp.mutez(1_000_000)).run(sender = creator)


    scenario.h1(&#34;Time&#34;)
    scenario.h2(&#34;set_time()&#34;)
    c1.set_time(sp.record(min=1*DAY, max=366*DAY)).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.set_time(sp.record(min=3*DAY, max=60*DAY)).run(sender = userA, valid = False)
    c1.set_time(sp.record(min=0*DAY, max=366*DAY)).run(sender = creator, valid = False)
    c1.set_time(sp.record(min=180*DAY, max=7*DAY)).run(sender = creator, valid = False)
    c1.set_time(sp.record(min=1*DAY, max=366*DAY)).run(sender = admin)
    c1.set_time(sp.record(min=1*DAY, max=366*DAY)).run(sender = creator, valid = False)


    scenario.h1(&#34;Loans&#34;)
    scenario.h2(&#34;add_loan()&#34;)
    c1.add_loan(amount=10_000, token=&#34;abcd&#34;, token_address=tokenETH.address, time=7*DAY, reward=1000,
        deposit=sp.mutez(1_500_000_00), validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=sp.address(&#34;tz1fwnfJNgiDACshK9avfRfFbMaXrs3ghoJa&#34;), time=7*DAY, reward=1000,
        deposit=sp.mutez(1_500_000_00), validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    c1.add_loan(amount=0, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=1000,
        deposit=sp.mutez(1_500_000_00), validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=1000,
        deposit=sp.mutez(1), validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=1, reward=1000,
        deposit=sp.mutez(1_500_000_00), validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=456*DAY, reward=1000,
        deposit=sp.mutez(1_500_000_00), validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=1000,
        deposit=sp.mutez(1_500_000_00), validity=sp.some(sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=1000,
        deposit=sp.mutez(1_500_000_00), validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=1000, deposit=sp.mutez(1_500_000_00),
        validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.add_loan(amount=20_000, token=tokenBTC.name, token_address=tokenBTC.address, time=14*DAY, reward=200, deposit=sp.mutez(200_000_000),
        validity=sp.none
        ).run(sender=userB, amount=sp.mutez(200_000_000 + 76712), now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0))
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=100, deposit=sp.mutez(1_000_000),
        validity=sp.some(sp.timestamp_from_utc(2022, 5, 3, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_000_000 + 191), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=1000, deposit=sp.mutez(1_500_000_00),
        validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_500_000_00 + 28767), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=1000, deposit=sp.mutez(1_000_000),
        validity=sp.some(sp.timestamp_from_utc(2022, 5, 3, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_000_000 + 191), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.add_loan(amount=20_000, token=&#34;eth&#34;, token_address=tokenETH.address, time=14*DAY, reward=200, deposit=sp.mutez(200_000_000),
        validity=sp.none
        ).run(sender=userB, amount=sp.mutez(200_000_000 + 76712), now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0), valid=False)
    c1.add_loan(amount=20_000, token=tokenBTC.name, token_address=tokenETH.address, time=14*DAY, reward=200, deposit=sp.mutez(200_000_000),
        validity=sp.none
        ).run(sender=userB, amount=sp.mutez(200_000_000 + 76712), now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0), valid=False)
    scenario.h2(&#34;cancel_loan()&#34;)
    c1.cancel_loan(id=1).run(sender = userA, amount=sp.mutez(1), valid = False)
    c1.cancel_loan(id=123).run(sender = userA, valid = False)
    c1.cancel_loan(id=3).run(sender = userB, valid = False)
    c1.cancel_loan(id=1).run(sender = userA)
    c1.cancel_loan(id=3).run(sender = admin)


    scenario.h1(&#34;Deals&#34;)
    scenario.h2(&#34;make_deal()&#34;)
    c1.make_deal(id=1).run(sender=userB, valid = False)
    c1.make_deal(id=4).run(sender=userA, valid = False)
    c1.make_deal(id=4).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 15, 0, 0, 0), valid = False)
    c1.make_deal(id=4).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 10, 0, 0, 0), amount=sp.mutez(1), valid = False)
    c1.make_deal(id=4).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 10, 0, 0, 0))
    c1.make_deal(id=5).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    scenario.h2(&#34;close_deal()&#34;)
    c1.close_deal(id=0).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 11, 0, 0, 0), valid = False)
    c1.close_deal(id=1).run(sender=userC, now=sp.timestamp_from_utc(2022, 5, 11, 0, 0, 0), valid = False)
    c1.close_deal(id=1).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 11, 0, 0, 0), valid = False)
    c1.close_deal(id=1).run(sender=admin, now=sp.timestamp_from_utc(2022, 5, 11, 0, 0, 0), valid = False)
    c1.close_deal(id=1).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0), amount=sp.mutez(1), valid = False)
    c1.close_deal(id=1).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
    c1.close_deal(id=2).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 9, 0, 0, 0))


    scenario.h1(&#34;Pause&#34;)
    scenario.h2(&#34;pause()&#34;)
    c1.pause(pause=True).run(sender = admin, amount=sp.mutez(1), valid = False)
    c1.pause(pause=False).run(sender = userA, valid = False)
    c1.pause(pause=False).run(sender = admin, valid = False)
    c1.pause(pause=True).run(sender = admin)
    # Creating new loan request is not possible
    c1.add_loan(amount=10_000, token=tokenETH.name, token_address=tokenETH.address, time=7*DAY, reward=100, deposit=sp.mutez(1_000_000),
        validity=sp.some(sp.timestamp_from_utc(2022, 5, 3, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(1_000_000 + 191), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    # Making deal is not possible
    c1.make_deal(id=2).run(sender=userC, valid = False)


    scenario.h1(&#34;Withdraw&#34;)
    scenario.h2(&#34;withdraw()&#34;)
    c1.withdraw(address=admin.address, amount=sp.mutez(1)).run(sender = userA, valid = False)
    c1.withdraw(address=admin.address, amount=sp.mutez(0)).run(sender = creator, valid = False)
    c1.withdraw(address=admin.address, amount=sp.tez(1000000)).run(sender = admin, valid = False)
    c1.withdraw(address=admin.address, amount=INITIAL_BALANCE).run(sender = admin)
    scenario.verify(c1.balance &gt;= c1.data.deposits)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="contract.Error"><code class="flex name class">
<span>class <span class="ident">Error</span></span>
</code></dt>
<dd>
<div class="desc"><p>The enum used for the contract related errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Error:
    &#34;&#34;&#34;The enum used for the contract related errors.&#34;&#34;&#34;

    ACCESS_DENIED = &#34;OD_ACCESS_DENIED&#34;
    &#34;&#34;&#34;The contract function is not accessible for the sender.&#34;&#34;&#34;

    ILLEGAL_ARGUMENT = &#34;OD_ILLEGAL_ARGUMENT&#34;
    &#34;&#34;&#34;The corresponding argument value is invalid.&#34;&#34;&#34;

    ILLEGAL_TX_AMOUNT = &#34;OD_ILLEGAL_TX_AMOUNT&#34;
    &#34;&#34;&#34;The corresponding transaction has incorrect tezos amount.&#34;&#34;&#34;

    PAUSED = &#34;OD_PAUSED&#34;
    &#34;&#34;&#34;The contract is paused.&#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="contract.Error.ACCESS_DENIED"><code class="name">var <span class="ident">ACCESS_DENIED</span></code></dt>
<dd>
<div class="desc"><p>The contract function is not accessible for the sender.</p></div>
</dd>
<dt id="contract.Error.ILLEGAL_ARGUMENT"><code class="name">var <span class="ident">ILLEGAL_ARGUMENT</span></code></dt>
<dd>
<div class="desc"><p>The corresponding argument value is invalid.</p></div>
</dd>
<dt id="contract.Error.ILLEGAL_TX_AMOUNT"><code class="name">var <span class="ident">ILLEGAL_TX_AMOUNT</span></code></dt>
<dd>
<div class="desc"><p>The corresponding transaction has incorrect tezos amount.</p></div>
</dd>
<dt id="contract.Error.PAUSED"><code class="name">var <span class="ident">PAUSED</span></code></dt>
<dd>
<div class="desc"><p>The contract is paused.</p></div>
</dd>
</dl>
</dd>
<dt id="contract.Opus"><code class="flex name class">
<span>class <span class="ident">Opus</span></span>
<span>(</span><span>creator)</span>
</code></dt>
<dd>
<div class="desc"><p>The contract is a storage for p2p credit deals and provides service functionality to make such deals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Opus(sp.Contract):
    &#34;&#34;&#34;The contract is a storage for p2p credit deals and provides service functionality to make such deals.&#34;&#34;&#34;

    def __init__(self, creator):
        self.creator = creator

        self.init(
            # indicates that making of credit deals is disabled
            # (if the value is True, creating loan requests and making deals are not possible)
            pause = False,

            # baker address or None
            baker = sp.none,

            # list of admin addresses
            admins = sp.set([creator]),

            # supported tokens (list of pairs: token name and token address)
            tokens = sp.big_map(tkey = sp.TString, tvalue = sp.TAddress),

            # time bounds for credit deals
            time = sp.record(min = sp.nat(7 * 86400), max = sp.nat(180 * 86400)),

            # minimum deposit value
            min_deposit = sp.tez(1),

            # service fee (APY) in basis points
            fee = sp.nat(100),

            # last loan request ID
            nloan = sp.nat(0),

            # last credit deal ID
            ndeal = sp.nat(0),

            # map of loan requests (key is loan request ID)
            loans = sp.big_map(),

            # map of credit deals (key is credit deal ID)
            deals = sp.big_map(),

            # amount of blocked collateral
            deposits = sp.mutez(0)
        )


    @sp.entry_point
    def default(self):
        &#34;&#34;&#34;Support tezos transfer to the contract address.&#34;&#34;&#34;
        pass


    @sp.entry_point
    def withdraw(self, params):
        &#34;&#34;&#34;(Admins only) Transfer tezos (except blocked collateral) from the contract address.
        
        Args:
            address (address): destination address
            amount (mutez): tezos amount
        Raises:
            `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.set_type(params.amount, sp.TMutez)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(params.amount &gt; sp.mutez(0), message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.verify((sp.balance - self.data.deposits) &gt;= params.amount, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.send(params.address, params.amount)


    @sp.entry_point
    def add_admin(self, params):
        &#34;&#34;&#34;(Admins only) Add an admin address to the list of admin addresses.
        
        Args:
            address (address): new admin address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(~self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        self.data.admins.add(params.address)


    @sp.entry_point
    def remove_admin(self, params):
        &#34;&#34;&#34;(Admins only) Remove an admin address from the list of admin addresses.

        Args:
            address (address): admin address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.creator != params.address, message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        sp.verify(self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        self.data.admins.remove(params.address)


    @sp.entry_point
    def pause(self, params):
        &#34;&#34;&#34;(Admins only) Disable/enable making of new loan requests and new deals.

        Args:
            pause (bool): _True_ or _False_
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.pause, sp.TBool)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.pause != params.pause, message = Error.ILLEGAL_ARGUMENT + &#34;:pause&#34;)
        self.data.pause = params.pause


    @sp.entry_point
    def delegate(self, params):
        &#34;&#34;&#34;(Admins only) Set a baker for the contract.

        Args:
            baker (option): baker address or _None_
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.baker, sp.TOption(sp.TKeyHash))
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.baker != params.baker, message = Error.ILLEGAL_ARGUMENT + &#34;:baker&#34;)
        self.data.baker = params.baker
        sp.set_delegate(params.baker)


    @sp.entry_point
    def add_token(self, params):
        &#34;&#34;&#34;(Admins only) Add supported token.

        Args:
            name (string): token name
            address (address): token address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`
        &#34;&#34;&#34;
        sp.set_type(params.name, sp.TString)
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        self.data.tokens[params.name] = params.address


    @sp.entry_point
    def remove_token(self, params):
        &#34;&#34;&#34;(Admins only) Remove supported token.

        Args:
            name (string): token name
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.name, sp.TString)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.tokens.contains(params.name), message = Error.ILLEGAL_ARGUMENT + &#34;:name&#34;)
        del self.data.tokens[params.name]


    @sp.entry_point
    def set_fee(self, params):
        &#34;&#34;&#34;(Admins only) Set a service fee.

        Args:
            fee (nat): fee value (APY) in basis points
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.fee, sp.TNat)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.fee != params.fee, message = Error.ILLEGAL_ARGUMENT + &#34;:fee&#34;)
        sp.verify(params.fee &lt; 10000, message = Error.ILLEGAL_ARGUMENT + &#34;:fee&#34;)
        self.data.fee = params.fee


    @sp.entry_point
    def set_min_deposit(self, params):
        &#34;&#34;&#34;(Admins only) Set minimum deposit value for loan requests.

        Args:
            min_deposit (mutez): minimum deposit value
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.min_deposit, sp.TMutez)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.min_deposit != params.min_deposit, message = Error.ILLEGAL_ARGUMENT + &#34;:min_deposit&#34;)
        self.data.min_deposit = params.min_deposit


    @sp.entry_point
    def set_time(self, params):
        &#34;&#34;&#34;(Admins only) Set time bounds for credit deals.

        Args:
            min (nat): minimum deal duration in seconds
            max (nat): maximum deal duration in seconds
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params, sp.TRecord(min = sp.TNat, max = sp.TNat))
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.time != params, message = Error.ILLEGAL_ARGUMENT + &#34;:min,max&#34;)
        sp.verify((params.min &gt; 0) &amp; (params.min &lt;= params.max), message = Error.ILLEGAL_ARGUMENT + &#34;:min&#34;)
        self.data.time = params


    @sp.entry_point
    def add_loan(self, params):
        &#34;&#34;&#34;Create a new loan request.
        
        The corresponding transaction amount has to include deposit and service fee.

        Args:
            token (string): token name
            token_address (address): token address
            amount (nat): requested amount of tokens
            reward (nat): amount of tokens as creditor&#39;s reward 
            deposit (mutez): deposit amount, the sender has to send the same amount of tezos
            time (nat): credit deal duration in seconds
            validity (option): loan request expire date or None
        Raises:
            `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.token, sp.TString)
        sp.set_type(params.token_address, sp.TAddress)
        sp.set_type(params.amount, sp.TNat)
        sp.set_type(params.reward, sp.TNat)
        sp.set_type(params.deposit, sp.TMutez)
        sp.set_type(params.time, sp.TNat)
        sp.set_type(params.validity, sp.TOption(sp.TTimestamp))
        sp.verify(~self.data.pause, message = Error.PAUSED)
        sp.verify(self.data.tokens.contains(params.token), message = Error.ILLEGAL_ARGUMENT + &#34;:token&#34;)
        sp.verify(self.data.tokens[params.token] == params.token_address, message = Error.ILLEGAL_ARGUMENT + &#34;:token_address&#34;)
        sp.verify(params.amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.verify(params.deposit &gt;= self.data.min_deposit, message = Error.ILLEGAL_ARGUMENT + &#34;:deposit&#34;)
        sp.verify((params.time &gt;= self.data.time.min) &amp; (params.time &lt;= self.data.time.max), message = Error.ILLEGAL_ARGUMENT + &#34;:time&#34;)
        sp.verify((params.validity == sp.none) | (params.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:validity&#34;)
        # Service fee calculation
        f = sp.local(&#34;f&#34;, sp.utils.nat_to_mutez(sp.utils.mutez_to_nat(params.deposit) * params.time * self.data.fee // (3600 * 24 * 365 * 100 * 100)))
        sp.verify(sp.amount == (params.deposit + f.value), message = Error.ILLEGAL_TX_AMOUNT)
        loan = sp.record(
            ts = sp.now,
            borrower = sp.sender,
            validity = params.validity,
            amount = params.amount,
            token = params.token,
            token_address = self.data.tokens[params.token],
            time = params.time,
            reward = params.reward,
            deposit = params.deposit,
            fee = f.value
        )
        self.data.nloan += 1
        self.data.loans[self.data.nloan] = loan
        self.data.deposits += sp.amount


    @sp.entry_point
    def cancel_loan(self, params):
        &#34;&#34;&#34;Cancel sender&#39;s loan request, deposit and fee of the loan are returned to the sender.

        Args:
            id (nat): loan request ID
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
        sp.verify((sp.sender == loan.value.borrower) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
        with sp.if_(loan.value.deposit &gt; sp.mutez(0)):
            sp.send(loan.value.borrower, loan.value.deposit + loan.value.fee)
            self.data.deposits -= (loan.value.deposit + loan.value.fee)
        del self.data.loans[params.id]


    @sp.entry_point
    def make_deal(self, params):
        &#34;&#34;&#34;Make a credit deal, the sender has to approve the corresponding token transfer early.

        Args:
            id (nat): loan request ID
        Raises:
            `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(~self.data.pause, message = Error.PAUSED)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
        sp.verify(loan.value.borrower != sp.sender, Error.ILLEGAL_ARGUMENT + &#34;:sender&#34;)
        sp.verify((loan.value.validity == sp.none) | (loan.value.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:now&#34;)
        deal = sp.record(
            ts = sp.now,
            borrower = loan.value.borrower,
            creditor = sp.sender,
            amount = loan.value.amount,
            token = loan.value.token,
            token_address = loan.value.token_address,
            exp = sp.now.add_seconds(sp.to_int(loan.value.time)),
            reward = loan.value.reward,
            deposit = loan.value.deposit,
        )
        self.transfer_tokens(f=sp.sender, t=loan.value.borrower, v=loan.value.amount, token_address=loan.value.token_address)
        self.data.ndeal += 1
        self.data.deals[self.data.ndeal] = deal
        self.data.deposits -= loan.value.fee
        del self.data.loans[params.id]


    @sp.entry_point
    def close_deal(self, params):
        &#34;&#34;&#34;Close a deal by borrower or creditor/admins.

        If a deal is closed by borrower, the tokens are sent to the creditor and the borrower gets back the deposit;
        if a deal timed out and it&#39;s closed by the creditor or admins, the creditor gets the deposit.

        Args:
            id (nat): credit deal ID
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.deals.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        deal = sp.local(&#34;deal&#34;, self.data.deals[params.id])
        sp.verify((sp.sender == deal.value.borrower) | (sp.sender == deal.value.creditor) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
        with sp.if_(sp.sender == deal.value.borrower):
            self.transfer_tokens(f=deal.value.borrower, t=deal.value.creditor, v=(deal.value.amount+deal.value.reward), token_address=deal.value.token_address)
            with sp.if_(deal.value.deposit &gt; sp.mutez(0)):
                sp.send(deal.value.borrower, deal.value.deposit)
                self.data.deposits -= deal.value.deposit
        with sp.else_():
            sp.verify(deal.value.exp &lt; sp.now, message = Error.ACCESS_DENIED)
            with sp.if_(deal.value.deposit &gt; sp.mutez(0)):
                sp.send(deal.value.creditor, deal.value.deposit)
                self.data.deposits -= deal.value.deposit
        del self.data.deals[params.id]


    def transfer_tokens(self, f, t, v, token_address):
        &#34;&#34;&#34;Help function to transfer tokens.

        Args:
            f (address): source address
            t (address): destination address
            v (nat): amount of tokens
            token_address (address): token smart-contract address
        &#34;&#34;&#34;
        param_type = sp.TRecord(from_ = sp.TAddress, to_ = sp.TAddress, value = sp.TNat).layout((&#34;from_ as from&#34;, (&#34;to_ as to&#34;, &#34;value&#34;)))
        param_values = sp.record(from_ = f, to_ = t, value = v)
        sp.transfer(param_values, sp.mutez(0), sp.contract(param_type, token_address, entry_point=&#34;transfer&#34;).open_some())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>smartpy.Contract</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="contract.Opus.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Support tezos transfer to the contract address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def default(self):
    &#34;&#34;&#34;Support tezos transfer to the contract address.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="contract.Opus.withdraw"><code class="name flex">
<span>def <span class="ident">withdraw</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Transfer tezos (except blocked collateral) from the contract address.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>address</code></dt>
<dd>destination address</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>mutez</code></dt>
<dd>tezos amount</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def withdraw(self, params):
    &#34;&#34;&#34;(Admins only) Transfer tezos (except blocked collateral) from the contract address.
    
    Args:
        address (address): destination address
        amount (mutez): tezos amount
    Raises:
        `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.address, sp.TAddress)
    sp.set_type(params.amount, sp.TMutez)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(params.amount &gt; sp.mutez(0), message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
    sp.verify((sp.balance - self.data.deposits) &gt;= params.amount, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
    sp.send(params.address, params.amount)</code></pre>
</details>
</dd>
<dt id="contract.Opus.add_admin"><code class="name flex">
<span>def <span class="ident">add_admin</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Add an admin address to the list of admin addresses.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>address</code></dt>
<dd>new admin address</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def add_admin(self, params):
    &#34;&#34;&#34;(Admins only) Add an admin address to the list of admin addresses.
    
    Args:
        address (address): new admin address
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.address, sp.TAddress)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(~self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
    self.data.admins.add(params.address)</code></pre>
</details>
</dd>
<dt id="contract.Opus.remove_admin"><code class="name flex">
<span>def <span class="ident">remove_admin</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Remove an admin address from the list of admin addresses.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>address</code></dt>
<dd>admin address</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def remove_admin(self, params):
    &#34;&#34;&#34;(Admins only) Remove an admin address from the list of admin addresses.

    Args:
        address (address): admin address
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.address, sp.TAddress)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.creator != params.address, message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
    sp.verify(self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
    self.data.admins.remove(params.address)</code></pre>
</details>
</dd>
<dt id="contract.Opus.pause"><code class="name flex">
<span>def <span class="ident">pause</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Disable/enable making of new loan requests and new deals.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pause</code></strong> :&ensp;<code>bool</code></dt>
<dd><em>True</em> or <em>False</em></dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def pause(self, params):
    &#34;&#34;&#34;(Admins only) Disable/enable making of new loan requests and new deals.

    Args:
        pause (bool): _True_ or _False_
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.pause, sp.TBool)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.pause != params.pause, message = Error.ILLEGAL_ARGUMENT + &#34;:pause&#34;)
    self.data.pause = params.pause</code></pre>
</details>
</dd>
<dt id="contract.Opus.delegate"><code class="name flex">
<span>def <span class="ident">delegate</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Set a baker for the contract.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>baker</code></strong> :&ensp;<code>option</code></dt>
<dd>baker address or <em>None</em></dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def delegate(self, params):
    &#34;&#34;&#34;(Admins only) Set a baker for the contract.

    Args:
        baker (option): baker address or _None_
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.baker, sp.TOption(sp.TKeyHash))
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.baker != params.baker, message = Error.ILLEGAL_ARGUMENT + &#34;:baker&#34;)
    self.data.baker = params.baker
    sp.set_delegate(params.baker)</code></pre>
</details>
</dd>
<dt id="contract.Opus.add_token"><code class="name flex">
<span>def <span class="ident">add_token</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Add supported token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>token name</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>address</code></dt>
<dd>token address</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def add_token(self, params):
    &#34;&#34;&#34;(Admins only) Add supported token.

    Args:
        name (string): token name
        address (address): token address
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`
    &#34;&#34;&#34;
    sp.set_type(params.name, sp.TString)
    sp.set_type(params.address, sp.TAddress)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    self.data.tokens[params.name] = params.address</code></pre>
</details>
</dd>
<dt id="contract.Opus.remove_token"><code class="name flex">
<span>def <span class="ident">remove_token</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Remove supported token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>token name</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def remove_token(self, params):
    &#34;&#34;&#34;(Admins only) Remove supported token.

    Args:
        name (string): token name
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.name, sp.TString)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.tokens.contains(params.name), message = Error.ILLEGAL_ARGUMENT + &#34;:name&#34;)
    del self.data.tokens[params.name]</code></pre>
</details>
</dd>
<dt id="contract.Opus.set_fee"><code class="name flex">
<span>def <span class="ident">set_fee</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Set a service fee.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fee</code></strong> :&ensp;<code>nat</code></dt>
<dd>fee value (APY) in basis points</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def set_fee(self, params):
    &#34;&#34;&#34;(Admins only) Set a service fee.

    Args:
        fee (nat): fee value (APY) in basis points
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.fee, sp.TNat)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.fee != params.fee, message = Error.ILLEGAL_ARGUMENT + &#34;:fee&#34;)
    sp.verify(params.fee &lt; 10000, message = Error.ILLEGAL_ARGUMENT + &#34;:fee&#34;)
    self.data.fee = params.fee</code></pre>
</details>
</dd>
<dt id="contract.Opus.set_min_deposit"><code class="name flex">
<span>def <span class="ident">set_min_deposit</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Set minimum deposit value for loan requests.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>min_deposit</code></strong> :&ensp;<code>mutez</code></dt>
<dd>minimum deposit value</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def set_min_deposit(self, params):
    &#34;&#34;&#34;(Admins only) Set minimum deposit value for loan requests.

    Args:
        min_deposit (mutez): minimum deposit value
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.min_deposit, sp.TMutez)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.min_deposit != params.min_deposit, message = Error.ILLEGAL_ARGUMENT + &#34;:min_deposit&#34;)
    self.data.min_deposit = params.min_deposit</code></pre>
</details>
</dd>
<dt id="contract.Opus.set_time"><code class="name flex">
<span>def <span class="ident">set_time</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Set time bounds for credit deals.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>min</code></strong> :&ensp;<code>nat</code></dt>
<dd>minimum deal duration in seconds</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>nat</code></dt>
<dd>maximum deal duration in seconds</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def set_time(self, params):
    &#34;&#34;&#34;(Admins only) Set time bounds for credit deals.

    Args:
        min (nat): minimum deal duration in seconds
        max (nat): maximum deal duration in seconds
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params, sp.TRecord(min = sp.TNat, max = sp.TNat))
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.time != params, message = Error.ILLEGAL_ARGUMENT + &#34;:min,max&#34;)
    sp.verify((params.min &gt; 0) &amp; (params.min &lt;= params.max), message = Error.ILLEGAL_ARGUMENT + &#34;:min&#34;)
    self.data.time = params</code></pre>
</details>
</dd>
<dt id="contract.Opus.add_loan"><code class="name flex">
<span>def <span class="ident">add_loan</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Create a new loan request.</p>
<p>The corresponding transaction amount has to include deposit and service fee.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code>string</code></dt>
<dd>token name</dd>
<dt><strong><code>token_address</code></strong> :&ensp;<code>address</code></dt>
<dd>token address</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>nat</code></dt>
<dd>requested amount of tokens</dd>
<dt><strong><code>reward</code></strong> :&ensp;<code>nat</code></dt>
<dd>amount of tokens as creditor's reward </dd>
<dt><strong><code>deposit</code></strong> :&ensp;<code>mutez</code></dt>
<dd>deposit amount, the sender has to send the same amount of tezos</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>nat</code></dt>
<dd>credit deal duration in seconds</dd>
<dt><strong><code>validity</code></strong> :&ensp;<code>option</code></dt>
<dd>loan request expire date or None</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_PAUSED</code>, <code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def add_loan(self, params):
    &#34;&#34;&#34;Create a new loan request.
    
    The corresponding transaction amount has to include deposit and service fee.

    Args:
        token (string): token name
        token_address (address): token address
        amount (nat): requested amount of tokens
        reward (nat): amount of tokens as creditor&#39;s reward 
        deposit (mutez): deposit amount, the sender has to send the same amount of tezos
        time (nat): credit deal duration in seconds
        validity (option): loan request expire date or None
    Raises:
        `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.token, sp.TString)
    sp.set_type(params.token_address, sp.TAddress)
    sp.set_type(params.amount, sp.TNat)
    sp.set_type(params.reward, sp.TNat)
    sp.set_type(params.deposit, sp.TMutez)
    sp.set_type(params.time, sp.TNat)
    sp.set_type(params.validity, sp.TOption(sp.TTimestamp))
    sp.verify(~self.data.pause, message = Error.PAUSED)
    sp.verify(self.data.tokens.contains(params.token), message = Error.ILLEGAL_ARGUMENT + &#34;:token&#34;)
    sp.verify(self.data.tokens[params.token] == params.token_address, message = Error.ILLEGAL_ARGUMENT + &#34;:token_address&#34;)
    sp.verify(params.amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
    sp.verify(params.deposit &gt;= self.data.min_deposit, message = Error.ILLEGAL_ARGUMENT + &#34;:deposit&#34;)
    sp.verify((params.time &gt;= self.data.time.min) &amp; (params.time &lt;= self.data.time.max), message = Error.ILLEGAL_ARGUMENT + &#34;:time&#34;)
    sp.verify((params.validity == sp.none) | (params.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:validity&#34;)
    # Service fee calculation
    f = sp.local(&#34;f&#34;, sp.utils.nat_to_mutez(sp.utils.mutez_to_nat(params.deposit) * params.time * self.data.fee // (3600 * 24 * 365 * 100 * 100)))
    sp.verify(sp.amount == (params.deposit + f.value), message = Error.ILLEGAL_TX_AMOUNT)
    loan = sp.record(
        ts = sp.now,
        borrower = sp.sender,
        validity = params.validity,
        amount = params.amount,
        token = params.token,
        token_address = self.data.tokens[params.token],
        time = params.time,
        reward = params.reward,
        deposit = params.deposit,
        fee = f.value
    )
    self.data.nloan += 1
    self.data.loans[self.data.nloan] = loan
    self.data.deposits += sp.amount</code></pre>
</details>
</dd>
<dt id="contract.Opus.cancel_loan"><code class="name flex">
<span>def <span class="ident">cancel_loan</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Cancel sender's loan request, deposit and fee of the loan are returned to the sender.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>nat</code></dt>
<dd>loan request ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def cancel_loan(self, params):
    &#34;&#34;&#34;Cancel sender&#39;s loan request, deposit and fee of the loan are returned to the sender.

    Args:
        id (nat): loan request ID
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.id, sp.TNat)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
    sp.verify((sp.sender == loan.value.borrower) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
    with sp.if_(loan.value.deposit &gt; sp.mutez(0)):
        sp.send(loan.value.borrower, loan.value.deposit + loan.value.fee)
        self.data.deposits -= (loan.value.deposit + loan.value.fee)
    del self.data.loans[params.id]</code></pre>
</details>
</dd>
<dt id="contract.Opus.make_deal"><code class="name flex">
<span>def <span class="ident">make_deal</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Make a credit deal, the sender has to approve the corresponding token transfer early.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>nat</code></dt>
<dd>loan request ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_PAUSED</code>, <code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def make_deal(self, params):
    &#34;&#34;&#34;Make a credit deal, the sender has to approve the corresponding token transfer early.

    Args:
        id (nat): loan request ID
    Raises:
        `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.id, sp.TNat)
    sp.verify(~self.data.pause, message = Error.PAUSED)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
    sp.verify(loan.value.borrower != sp.sender, Error.ILLEGAL_ARGUMENT + &#34;:sender&#34;)
    sp.verify((loan.value.validity == sp.none) | (loan.value.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:now&#34;)
    deal = sp.record(
        ts = sp.now,
        borrower = loan.value.borrower,
        creditor = sp.sender,
        amount = loan.value.amount,
        token = loan.value.token,
        token_address = loan.value.token_address,
        exp = sp.now.add_seconds(sp.to_int(loan.value.time)),
        reward = loan.value.reward,
        deposit = loan.value.deposit,
    )
    self.transfer_tokens(f=sp.sender, t=loan.value.borrower, v=loan.value.amount, token_address=loan.value.token_address)
    self.data.ndeal += 1
    self.data.deals[self.data.ndeal] = deal
    self.data.deposits -= loan.value.fee
    del self.data.loans[params.id]</code></pre>
</details>
</dd>
<dt id="contract.Opus.close_deal"><code class="name flex">
<span>def <span class="ident">close_deal</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Close a deal by borrower or creditor/admins.</p>
<p>If a deal is closed by borrower, the tokens are sent to the creditor and the borrower gets back the deposit;
if a deal timed out and it's closed by the creditor or admins, the creditor gets the deposit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>nat</code></dt>
<dd>credit deal ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def close_deal(self, params):
    &#34;&#34;&#34;Close a deal by borrower or creditor/admins.

    If a deal is closed by borrower, the tokens are sent to the creditor and the borrower gets back the deposit;
    if a deal timed out and it&#39;s closed by the creditor or admins, the creditor gets the deposit.

    Args:
        id (nat): credit deal ID
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.id, sp.TNat)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.deals.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    deal = sp.local(&#34;deal&#34;, self.data.deals[params.id])
    sp.verify((sp.sender == deal.value.borrower) | (sp.sender == deal.value.creditor) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
    with sp.if_(sp.sender == deal.value.borrower):
        self.transfer_tokens(f=deal.value.borrower, t=deal.value.creditor, v=(deal.value.amount+deal.value.reward), token_address=deal.value.token_address)
        with sp.if_(deal.value.deposit &gt; sp.mutez(0)):
            sp.send(deal.value.borrower, deal.value.deposit)
            self.data.deposits -= deal.value.deposit
    with sp.else_():
        sp.verify(deal.value.exp &lt; sp.now, message = Error.ACCESS_DENIED)
        with sp.if_(deal.value.deposit &gt; sp.mutez(0)):
            sp.send(deal.value.creditor, deal.value.deposit)
            self.data.deposits -= deal.value.deposit
    del self.data.deals[params.id]</code></pre>
</details>
</dd>
<dt id="contract.Opus.transfer_tokens"><code class="name flex">
<span>def <span class="ident">transfer_tokens</span></span>(<span>self, f, t, v, token_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Help function to transfer tokens.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>address</code></dt>
<dd>source address</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>address</code></dt>
<dd>destination address</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>nat</code></dt>
<dd>amount of tokens</dd>
<dt><strong><code>token_address</code></strong> :&ensp;<code>address</code></dt>
<dd>token smart-contract address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_tokens(self, f, t, v, token_address):
    &#34;&#34;&#34;Help function to transfer tokens.

    Args:
        f (address): source address
        t (address): destination address
        v (nat): amount of tokens
        token_address (address): token smart-contract address
    &#34;&#34;&#34;
    param_type = sp.TRecord(from_ = sp.TAddress, to_ = sp.TAddress, value = sp.TNat).layout((&#34;from_ as from&#34;, (&#34;to_ as to&#34;, &#34;value&#34;)))
    param_values = sp.record(from_ = f, to_ = t, value = v)
    sp.transfer(param_values, sp.mutez(0), sp.contract(param_type, token_address, entry_point=&#34;transfer&#34;).open_some())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="contract.Error" href="#contract.Error">Error</a></code></h4>
<ul class="">
<li><code><a title="contract.Error.ACCESS_DENIED" href="#contract.Error.ACCESS_DENIED">ACCESS_DENIED</a></code></li>
<li><code><a title="contract.Error.ILLEGAL_ARGUMENT" href="#contract.Error.ILLEGAL_ARGUMENT">ILLEGAL_ARGUMENT</a></code></li>
<li><code><a title="contract.Error.ILLEGAL_TX_AMOUNT" href="#contract.Error.ILLEGAL_TX_AMOUNT">ILLEGAL_TX_AMOUNT</a></code></li>
<li><code><a title="contract.Error.PAUSED" href="#contract.Error.PAUSED">PAUSED</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="contract.Opus" href="#contract.Opus">Opus</a></code></h4>
<ul class="two-column">
<li><code><a title="contract.Opus.default" href="#contract.Opus.default">default</a></code></li>
<li><code><a title="contract.Opus.withdraw" href="#contract.Opus.withdraw">withdraw</a></code></li>
<li><code><a title="contract.Opus.add_admin" href="#contract.Opus.add_admin">add_admin</a></code></li>
<li><code><a title="contract.Opus.remove_admin" href="#contract.Opus.remove_admin">remove_admin</a></code></li>
<li><code><a title="contract.Opus.pause" href="#contract.Opus.pause">pause</a></code></li>
<li><code><a title="contract.Opus.delegate" href="#contract.Opus.delegate">delegate</a></code></li>
<li><code><a title="contract.Opus.add_token" href="#contract.Opus.add_token">add_token</a></code></li>
<li><code><a title="contract.Opus.remove_token" href="#contract.Opus.remove_token">remove_token</a></code></li>
<li><code><a title="contract.Opus.set_fee" href="#contract.Opus.set_fee">set_fee</a></code></li>
<li><code><a title="contract.Opus.set_min_deposit" href="#contract.Opus.set_min_deposit">set_min_deposit</a></code></li>
<li><code><a title="contract.Opus.set_time" href="#contract.Opus.set_time">set_time</a></code></li>
<li><code><a title="contract.Opus.add_loan" href="#contract.Opus.add_loan">add_loan</a></code></li>
<li><code><a title="contract.Opus.cancel_loan" href="#contract.Opus.cancel_loan">cancel_loan</a></code></li>
<li><code><a title="contract.Opus.make_deal" href="#contract.Opus.make_deal">make_deal</a></code></li>
<li><code><a title="contract.Opus.close_deal" href="#contract.Opus.close_deal">close_deal</a></code></li>
<li><code><a title="contract.Opus.transfer_tokens" href="#contract.Opus.transfer_tokens">transfer_tokens</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>